# Version and Commit Embedding

## Pattern Overview

1. Placeholder file checked into git with "n/a" value
2. CI script replaces it with actual commit during Xcode Cloud builds
3. Displayed in settings for debugging

## GitCommit.swift

Create `ProjectName/GitCommit.swift`:

```swift
//
//  GitCommit.swift
//  ProjectName
//
//  This file is auto-generated during build by ci_post_clone.sh
//

import Foundation

struct GitCommit {
    static let hash: String = "n/a"
}
```

## ci_post_clone.sh

Create `ci_scripts/ci_post_clone.sh`:

```bash
#!/bin/sh
set -e

GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

if [ -n "$CI_WORKSPACE" ]; then
    OUTPUT_FILE="${CI_WORKSPACE}/ProjectName/GitCommit.swift"
else
    OUTPUT_FILE="$(dirname "$(pwd)")/ProjectName/GitCommit.swift"
fi

cat > "$OUTPUT_FILE" << EOF
//
//  GitCommit.swift
//  Auto-generated by ci_post_clone.sh
//

import Foundation

struct GitCommit {
    static let hash: String = "$GIT_COMMIT"
}
EOF

echo "Generated GitCommit.swift with commit hash: $GIT_COMMIT"
```

Make executable: `chmod +x ci_scripts/ci_post_clone.sh`

## Display in Settings

```swift
struct SettingsView: View {
    var body: some View {
        Section("About") {
            LabeledContent("Version", value: appVersion)
            LabeledContent("Build", value: buildNumber)
            LabeledContent("Commit", value: GitCommit.hash)
        }
    }

    private var appVersion: String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? "Unknown"
    }

    private var buildNumber: String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") as? String ?? "Unknown"
    }
}
```

## Automatic Version Bumping

Create `.github/scripts/bump_version.py`:

```python
#!/usr/bin/env python3
import re
import sys

def bump_version(file_path):
    with open(file_path, 'r') as f:
        content = f.read()

    pattern = r'MARKETING_VERSION = (\d+)\.(\d+);'
    match = re.search(pattern, content)

    if not match:
        print("Could not find MARKETING_VERSION")
        sys.exit(1)

    major, minor = int(match.group(1)), int(match.group(2))
    new_version = f"{major}.{minor + 1}"

    new_content = re.sub(pattern, f'MARKETING_VERSION = {new_version};', content)

    with open(file_path, 'w') as f:
        f.write(new_content)

    print(f"Bumped version: {major}.{minor} -> {new_version}")

if __name__ == "__main__":
    bump_version(sys.argv[1])
```

## Server-Side Commit Embedding

For Docker containers:

```dockerfile
ARG GIT_COMMIT=unknown
ENV GIT_COMMIT=${GIT_COMMIT}
```

Build with: `docker build --build-arg GIT_COMMIT=$(git rev-parse --short HEAD) .`
