# Version and Commit Embedding

Embed the git commit hash into the app for easy debugging. When users report issues, you can correlate their version and commit with the exact code they're running.

## The Pattern

1. **Placeholder file** checked into git with "n/a" value
2. **CI script** that replaces it with actual commit hash during Xcode Cloud builds
3. **Display in settings** alongside version and build number

## GitCommit.swift (Placeholder)

Create `ProjectName/GitCommit.swift`:

```swift
//
//  GitCommit.swift
//  ProjectName
//
//  This file is auto-generated during build by ci_post_clone.sh
//  Placeholder value will be replaced with actual git commit hash
//

import Foundation

struct GitCommit {
    static let hash: String = "n/a"
}
```

Check this file into git. The "n/a" value appears during local development.

## Xcode Cloud Script

Create `ci_scripts/ci_post_clone.sh`:

```bash
#!/bin/sh

# This script runs after Xcode Cloud clones the repository
# It generates a Swift file containing the current git commit hash

set -e

# Get the short commit hash (7 characters)
GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Define the output file path
# CI_WORKSPACE is set by Xcode Cloud, fallback to parent directory for local testing
if [ -n "$CI_WORKSPACE" ]; then
    OUTPUT_FILE="${CI_WORKSPACE}/ProjectName/GitCommit.swift"
else
    # Script runs from ci_scripts directory, so go up one level
    OUTPUT_FILE="$(dirname "$(pwd)")/ProjectName/GitCommit.swift"
fi

# Generate the Swift file with the commit hash
cat > "$OUTPUT_FILE" << EOF
//
//  GitCommit.swift
//  ProjectName
//
//  Auto-generated by ci_post_clone.sh
//

import Foundation

struct GitCommit {
    static let hash: String = "$GIT_COMMIT"
}
EOF

echo "Generated GitCommit.swift with commit hash: $GIT_COMMIT"
```

Make executable: `chmod +x ci_scripts/ci_post_clone.sh`

## Version Display in Settings

Display version info in your SettingsView:

```swift
import SwiftUI

struct SettingsView: View {
    var body: some View {
        Section("About") {
            LabeledContent("Version", value: appVersion)
            LabeledContent("Build", value: buildNumber)
            LabeledContent("Commit", value: GitCommit.hash)
        }
    }

    private var appVersion: String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? "Unknown"
    }

    private var buildNumber: String {
        Bundle.main.object(forInfoDictionaryKey: "CFBundleVersion") as? String ?? "Unknown"
    }
}
```

## Version Management in project.pbxproj

Version is stored in build settings:

```
MARKETING_VERSION = 1.5      // User-facing version (e.g., "1.5")
CURRENT_PROJECT_VERSION = 1  // Build number (incremented by Xcode Cloud)
```

## Automatic Version Bumping

Create `.github/scripts/bump_version.py` for automated version bumping:

```python
#!/usr/bin/env python3
import re
import sys

def bump_version(file_path):
    with open(file_path, 'r') as f:
        content = f.read()

    # Find current MARKETING_VERSION
    pattern = r'MARKETING_VERSION = (\d+)\.(\d+);'
    match = re.search(pattern, content)

    if not match:
        print("Could not find MARKETING_VERSION")
        sys.exit(1)

    major, minor = int(match.group(1)), int(match.group(2))
    new_version = f"{major}.{minor + 1}"

    # Replace all occurrences
    new_content = re.sub(pattern, f'MARKETING_VERSION = {new_version};', content)

    with open(file_path, 'w') as f:
        f.write(new_content)

    print(f"Bumped version: {major}.{minor} -> {new_version}")

if __name__ == "__main__":
    bump_version(sys.argv[1])
```

## GitHub Workflow for Version Bumping

See [server-docker.md](server-docker.md) for the full appstore-release.yml workflow that:
1. Checks App Store for new releases
2. Tags Docker images with the released version
3. Creates a PR to bump the version for the next development cycle

## Local Development

For local builds:
- GitCommit.hash shows "n/a"
- Can manually run `./ci_scripts/ci_post_clone.sh` to inject current commit
- Remember to reset before committing if you ran it locally

## Server-Side Commit Embedding

For server components, inject commit at Docker build time:

```dockerfile
ARG GIT_COMMIT=unknown
ENV GIT_COMMIT=${GIT_COMMIT}
```

Build with:
```bash
docker build --build-arg GIT_COMMIT=$(git rev-parse --short HEAD) .
```

Server logs can then include:
```python
import os
git_commit = os.environ.get('GIT_COMMIT', 'unknown')
print(f"Server starting, commit: {git_commit}")
```
